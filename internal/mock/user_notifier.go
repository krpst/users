// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/kl09/users"
	"github.com/oklog/ulid/v2"
	"sync"
)

// Ensure, that UserNotifierMock does implement users.UserNotifier.
// If this is not the case, regenerate this file with moq.
var _ users.UserNotifier = &UserNotifierMock{}

// UserNotifierMock is a mock implementation of users.UserNotifier.
//
//     func TestSomethingThatUsesUserNotifier(t *testing.T) {
//
//         // make and configure a mocked users.UserNotifier
//         mockedUserNotifier := &UserNotifierMock{
//             UserCreatedFunc: func(ctx context.Context, u users.User) error {
// 	               panic("mock out the UserCreated method")
//             },
//             UserDeletedFunc: func(ctx context.Context, id ulid.ULID) error {
// 	               panic("mock out the UserDeleted method")
//             },
//             UserUpdatedFunc: func(ctx context.Context, u users.User) error {
// 	               panic("mock out the UserUpdated method")
//             },
//         }
//
//         // use mockedUserNotifier in code that requires users.UserNotifier
//         // and then make assertions.
//
//     }
type UserNotifierMock struct {
	// UserCreatedFunc mocks the UserCreated method.
	UserCreatedFunc func(ctx context.Context, u users.User) error

	// UserDeletedFunc mocks the UserDeleted method.
	UserDeletedFunc func(ctx context.Context, id ulid.ULID) error

	// UserUpdatedFunc mocks the UserUpdated method.
	UserUpdatedFunc func(ctx context.Context, u users.User) error

	// calls tracks calls to the methods.
	calls struct {
		// UserCreated holds details about calls to the UserCreated method.
		UserCreated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// U is the u argument value.
			U users.User
		}
		// UserDeleted holds details about calls to the UserDeleted method.
		UserDeleted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID ulid.ULID
		}
		// UserUpdated holds details about calls to the UserUpdated method.
		UserUpdated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// U is the u argument value.
			U users.User
		}
	}
	lockUserCreated sync.RWMutex
	lockUserDeleted sync.RWMutex
	lockUserUpdated sync.RWMutex
}

// UserCreated calls UserCreatedFunc.
func (mock *UserNotifierMock) UserCreated(ctx context.Context, u users.User) error {
	callInfo := struct {
		Ctx context.Context
		U   users.User
	}{
		Ctx: ctx,
		U:   u,
	}
	mock.lockUserCreated.Lock()
	mock.calls.UserCreated = append(mock.calls.UserCreated, callInfo)
	mock.lockUserCreated.Unlock()
	if mock.UserCreatedFunc == nil {
		var (
			out1 error
		)
		return out1
	}
	return mock.UserCreatedFunc(ctx, u)
}

// UserCreatedCalls gets all the calls that were made to UserCreated.
// Check the length with:
//     len(mockedUserNotifier.UserCreatedCalls())
func (mock *UserNotifierMock) UserCreatedCalls() []struct {
	Ctx context.Context
	U   users.User
} {
	var calls []struct {
		Ctx context.Context
		U   users.User
	}
	mock.lockUserCreated.RLock()
	calls = mock.calls.UserCreated
	mock.lockUserCreated.RUnlock()
	return calls
}

// UserDeleted calls UserDeletedFunc.
func (mock *UserNotifierMock) UserDeleted(ctx context.Context, id ulid.ULID) error {
	callInfo := struct {
		Ctx context.Context
		ID  ulid.ULID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockUserDeleted.Lock()
	mock.calls.UserDeleted = append(mock.calls.UserDeleted, callInfo)
	mock.lockUserDeleted.Unlock()
	if mock.UserDeletedFunc == nil {
		var (
			out1 error
		)
		return out1
	}
	return mock.UserDeletedFunc(ctx, id)
}

// UserDeletedCalls gets all the calls that were made to UserDeleted.
// Check the length with:
//     len(mockedUserNotifier.UserDeletedCalls())
func (mock *UserNotifierMock) UserDeletedCalls() []struct {
	Ctx context.Context
	ID  ulid.ULID
} {
	var calls []struct {
		Ctx context.Context
		ID  ulid.ULID
	}
	mock.lockUserDeleted.RLock()
	calls = mock.calls.UserDeleted
	mock.lockUserDeleted.RUnlock()
	return calls
}

// UserUpdated calls UserUpdatedFunc.
func (mock *UserNotifierMock) UserUpdated(ctx context.Context, u users.User) error {
	callInfo := struct {
		Ctx context.Context
		U   users.User
	}{
		Ctx: ctx,
		U:   u,
	}
	mock.lockUserUpdated.Lock()
	mock.calls.UserUpdated = append(mock.calls.UserUpdated, callInfo)
	mock.lockUserUpdated.Unlock()
	if mock.UserUpdatedFunc == nil {
		var (
			out1 error
		)
		return out1
	}
	return mock.UserUpdatedFunc(ctx, u)
}

// UserUpdatedCalls gets all the calls that were made to UserUpdated.
// Check the length with:
//     len(mockedUserNotifier.UserUpdatedCalls())
func (mock *UserNotifierMock) UserUpdatedCalls() []struct {
	Ctx context.Context
	U   users.User
} {
	var calls []struct {
		Ctx context.Context
		U   users.User
	}
	mock.lockUserUpdated.RLock()
	calls = mock.calls.UserUpdated
	mock.lockUserUpdated.RUnlock()
	return calls
}
